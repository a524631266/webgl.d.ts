OpenGL中主要包括了两种数据——Buffer和Texture。

Buffer用于储存线性数无类型据块，可以看成普通的内存块，

Texture则用于储存多维数据，一般储存图像或者其他数据。
（创建Buffer对象和Texture对象的代码很类似）


# 1.缓冲区对象[地址](https://blog.csdn.net/lance710825/article/details/78137950)
缓冲区有许多不同的用途，它能保存顶点数据、像素数据、纹理数据、着色器处理的输入、或者不同着色器阶段的输出。
缓冲区保存在GPU内存中，它们提供高速和高效的访问。在OpenGL有缓冲区对象之前，应用程序只有有限的选择可以在GPU中存储数据。另外，在GPU中更新数据常常需要重新加载整个对象，而在系统内存和GPU内存之间来回移动数据常常是一个缓慢的过程，所以缓冲区对象应运而生。
# 2.绑定点（也是在GPU中）
在OpenGL中有许多不同的绑定点（binding point）,每个绑定点有着不同的作用，总体来说就是用来配置一些参数用的。我们可以将每个结合点或绑定点看做一个在同一时刻只能结合一个对象的槽。
# 2.1 比如 gl.ARRAY_BUFFER:数组缓冲区（可以）有权限存储颜色、位置、纹理坐标等顶点属性，或者其它自定义属性
# 2.2 比如 gl.TEXTURE_BUFFER（TEXTURE_2D /CUBE）: 着色器能够使用它， 图5.31
# 着色器与缓存区或者纹理图像数据之间的传入都需要经过特定的绑定点才能正常工作
# 3.帧缓冲区：到达帧缓冲区的像素将被显示到屏幕上

# 需要在配置好glsl之后，调用绘制的操作gl.drawArray或者gl.drawSomething,才能够通过缓冲区的数据持续向
# 着色器传递最终向屏幕打点绘图
# 顶点着色器 [地址](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html)
一个顶点着色器的工作是生成裁剪空间坐标值，通常是以下的形式
无论你的画布有多大 
裁剪空间的坐标范围永远是 -1 到 1 （正常的数学坐标）（可以画上去）
page 109 
执行顶点主色器的流程
page 165
# 片段着色器
网状由多个三角形形成，而每个三角形的表面被称为一个片段。片段着色器是在每个片段上的每个像素(每个像素)上运行代码。这是写入计算并填补单个像素的颜色。下面的任务可以使用片段着色来进行-
插值操作
[例子 三角形填充](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html)
# 两者工作原理
page141图以及page 147图 5.10 

# 两者密切相关的操作## 图 可见 5.11图
##1.图形装配工作，其主要目的，就是铅笔的描点，定位
##2.光栅化（片元化）工作，相当于在把大框架打成像素（片元），由点向面的过程（内插varing值，相当于告诉蜡笔，我之后将要在这个点附近图上颜色），
## 内插的算法 见5.16图


##3. 调用片元着色器
#在图形专配工作阶段就已经通过varing变化值进行传递的，默认会进行渐变
## 图 5.12 片元着色器会循环执行多少次是根据 片元化生成的数量决定